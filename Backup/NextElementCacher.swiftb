//
//  NextElementCacher.swift
//  Wideshow4
//
//  Created by Manuel Vrhovac on 26/09/2018.
//  Copyright Â© 2018 Manuel Vrhovac. All rights reserved.
//

import Foundation
import CoreLocation

/*

class ElementCacher<CacherProto: CacherProtocol>: NSObject {
    
    typealias Completion = (CacherProto.Result, Quality) -> Void

    
    var transformDelegate: CacherProto!
    
    

    
    
    // MARK: - User defined properties:
    
    var keyProvider: ElementSource<CacherProto.Element>!
    var indexGenerator: IndexGenerator!
    
    // MARK: - Private properties:
    
    // Already transformed(cached) keys into values
    
    private var values: [CacherProto.Element: CacherProto.Result] { return transformDelegate!.getResults(for: self) }
    private var quickResults: [CacherProto.Element: CacherProto.Result] { return transformDelegate!.getQuickResults(for: self) }
    
    
    private var isLoading: Bool = false
    private var checkNextElementTimer: Timer!

    private var priorityElement: CacherProto.Element!
    private var priorityBlock: Completion!
    
    
    override init() {
        super.init()
        startCaching()
    }
    
    
    /// Stop background caching
    func stopCaching() {
        checkNextElementTimer?.invalidate()
    }
    
    /// Start caching added assets in the background
    func startCaching() {
        checkNextElementTimer?.invalidate()
        checkNextElementTimer = Timer.scheduledTimer(withTimeInterval: 0.01, repeats: true) { _ in
            self.checkNextElement()
        }
    }
    
    
    func checkNextElement() {
        guard !isLoading else { return }
        if let priorityElement = priorityElement, let priorityBlock = priorityBlock {
            self.priorityElement = nil
            self.priorityBlock = nil
            return fetchFullNow(priorityElement) { value, quality in
                priorityBlock(value,quality)
            }
        }
        if let nextElement = keyProvider?.next/* ?? remainingElements.first */{
            // if maxSize is reached, then don't continue fetching more photos automatically
            let approximateSize = transformDelegate.approximateSizeCalculator(of: nextElement, for: self)
            guard approximateSize <= transformDelegate.maxSizeOfTransformBlock(for: self) else {
                checkNextElementTimer.invalidate()
                return
            }
            
            fetchFullNow(nextElement, completion: nil)
        }
    }
    
    func fetchFullNow(_ key: CacherProto.Element, completion: Completion?) {
        if let existing = values[key] {
            completion?(existing, .normal)
            return
        }
        isLoading = true
        transformDelegate.transform(for: key, for: self) { value,_  in
            self.isLoading = false
            completion?(value,.normal)
        }
    }
    
    func fetchQuickNow(_ key: CacherProto.Element, completion: Completion?) {
        if let existing = quickResults[key] {
            completion?(existing, .quick)
            return
        }
        transformDelegate.quickTransform(for: key, for: self) { value, _ in
            completion?(value,.quick)
        }
    }
    
    private func fetchFullAsap(_ key: CacherProto.Element, completion: Completion?) {
        if let existing = values[key] {
            completion?(existing, .normal)
            return
        }
        self.priorityElement = key
        self.priorityBlock = completion
    }
    
    
    public func transform(_ key: CacherProto.Element, method: Method, completion: Completion?) {
        if let existing = values[key] {
            completion?(existing, .normal)
            return
        }
        switch method {
        case .quickNow: fetchQuickNow(key, completion: completion)
        case .now: fetchFullNow(key, completion: completion)
        case .asap: fetchFullAsap(key, completion: completion)
        }
    }
    /*
    func fetchValue(for: asset: PHAsset?, method: Method, completion: Completion?) {
        guard let asset = asset else { return }
        /*if let existing = cachedImages[asset] {
         completion?(existing, true)
         return
         }*/
        switch method {
        case .nowSynchronous:
            fetchImageNow(for: asset, synchronous: true, completion: completion)
        case .now:
            fetchImageNow(for: asset, synchronous: false, completion: completion)
        case .asap:
            fetchImageAsap(for: asset, completion: completion)
        case .opportunistic:
            fetchThumbnailImageNow(for: asset, completion: completion)
            fetchImageAsap(for: asset, completion: completion)
        }
    }*/
}

*/

/*
 struct SizeLimits {
 var approximateSizeTransformBlock: ([Proto.Result]) -> Double = { _ in return 0.0 }
 var maxSizeForTransformBlock: Double = 1.0
 var maxSizeForQuickTransformBlock: Double = 1.0
 }
 
 struct Transformations {
 /// A block that takes the key, transforms it and delivers it inside the completion block (asynchroniously)
 var full: ((_ key: Proto.Element, _ completion: (Proto.Result) -> Void) -> Void)
 var quick: ((_ key: Proto.Element, _ completion: (Proto.Result) -> Void) -> Void)
 }
 */
