//
//  EFFectherBackup.swift
//  Wideshow4
//
//  Created by Manuel Vrhovac on 05/04/2019.
//  Copyright © 2019 Manuel Vrhovac. All rights reserved.
//

import Foundation

// Mark: - Prefetching

// REALLY OLD WAY OF FETCHING:
/*fileprivate func prefetchOld(valueNowFor newElement: E) {
 guard let cacher = cacher, let precacher = precacher else { return }
 
 // Fetching and caching can occur only if: The result can fit inside cacher or when cache is full (and bigger than range), so some objects outside of range can be cleaned to make room for ones that are in range.
 
 // Let's say range is 25. But cache becomes full with just 13 items cached. Now the 1st item would be taken out in order to cache the 14th item. In the next step, cache would then remove the 2nd item to make room for 15th and so on into eternity.
 
 let rangeIsFullyCached = cacher.allCachedResults.count >= precacher.options.range
 
 // 1. In case size can be calculated from key or can be approximated from average:
 //    Average will return size as 0.0 if cacher is empty, so it will pass through!
 
 
 
 switch cacher.memorySizeApproximation {
 case let .byElement(transforme):
 var size: Double! = nil
 if size == nil, case let .byElement(transform) = cacher.memorySizeApproximation {
 size = transform(newElement)
 }
 if let size = size, !cacher.couldFit(size: size) && !rangeIsFullyCached {
 print("Cannot even cache the whole range!")
 return
 }
 isPrefetching = true
 return executeFetchValue(for: newElement) { value in
 self.isPrefetching = false
 guard let value = value else { return }
 if size == nil, case let .byResult(transform) = cacher.memorySizeApproximation {
 size = transform(value)
 }
 guard cacher.couldFit(size: size) || rangeIsFullyCached else {
 print("Cannot even cache the whole range!")
 return
 }
 cacher.cache(value,removingAllowed: true, for: newElement)
 }
 case let .byResult(transformo):
 if let averageSize = cacher.averageSize {
 var size: Double! = averageSize
 if size == nil, case let .byElement(transform) = cacher.memorySizeApproximation {
 size = transform(newElement)
 }
 if let size = size, !cacher.couldFit(size: size) && !rangeIsFullyCached {
 print("Cannot even cache the whole range!")
 return
 }
 isPrefetching = true
 return executeFetchValue(for: newElement) { value in
 self.isPrefetching = false
 guard let value = value else { return }
 if size == nil, case let .byResult(transform) = cacher.memorySizeApproximation {
 size = transform(value)
 }
 guard cacher.couldFit(size: size) || rangeIsFullyCached else {
 print("Cannot even cache the whole range!")
 return
 }
 cacher.cache(value,removingAllowed: true, for: newElement)
 }
 }
 // 2: In case size needs to be calculated (result has to be fetched first):
 var size: Double! = nil
 if let size = size, !cacher.couldFit(size: size) && !rangeIsFullyCached {
 print("Cannot even cache the whole range!")
 return
 }
 isPrefetching = true
 executeFetchValue(for: newElement) { value in
 self.isPrefetching = false
 guard let value = value else { return }
 if size == nil, case let .byResult(transform) = cacher.memorySizeApproximation {
 size = transform(value)
 }
 guard cacher.couldFit(size: size) || rangeIsFullyCached else {
 print("Cannot even cache the whole range!")
 return
 }
 cacher.cache(value,removingAllowed: true, for: newElement)
 }
 }
 }*/

/* OLD WAYS OF FETCHING
 /// Similar as fetch but it doesn't force cache the result. Instead, it caches it only if it fits in the cache memory. Anyway, it calculates and remembers the memory size of the result.
 fileprivate func prefetchooo2(valueNowFor key: E) {
 guard let cacher = cacher, let precacher = precacher else { return }
 var size: Double? = nil
 
 // If using averageSize, don't measure anything. Get size from average!
 if precacher.options.approximateSizeByAverage {
 size = cacher.averageResultSize
 }
 // If not average, try to measure byElement
 else if let approximatedSize = cacher.approximateSize(of: elem) {
 size = approximatedSize
 }
 
 
 // If size is known by now, see if it's too big already
 let rangeIsFullyCached = cacher.cachedResults.count >= precacher.options.range
 if let size = size, !cacher.couldFit(size: size) && !rangeIsFullyCached {
 print("Range not full! Prefetcher return.")
 return
 }
 
 // Size could still be nil, fetch the item and calculate the size:
 isPrefetching = true
 return executeFetchValue(for: elem) { value in
 self.isPrefetching = false
 guard let value = value else { return }
 // If size is nil, calculate by analizing the result:
 if size == nil {
 size = cacher.approximateSize(of: value, for: elem)
 }
 guard let size = size, cacher.couldFit(size: size) || rangeIsFullyCached else {
 print("Range not full or size may still be unkown! Prefetcher return.")
 return
 }
 cacher.cache(value,removingAllowed: true, for: elem)
 }
 }*/

/*
 fileprivate func prefetchLimit(valueNowFor key: E) {
 guard let cacher = cacher, let precacher = precacher else { return }
 let canBeFreed = cacher.cachedResults.count >= precacher.options.range
 
 switch cacher.limit {
 case .none:
 return executePrefetchValue(for: for: elem)
 case let .count(max):
 guard cacher.cachedResults.count < max || canBeFreed else {
 return print("Range not full! Prefetcher return.")
 }
 return executePrefetchValue(for: for: elem)
 case let .memory(memory):
 let usedMemory = cacher.usedMemory(memoryLimit: memory)
 if let size = memory.approximateSize(of: elem), usedMemory + size < memory.max {
 guard (usedMemory + size < memory.max) || canBeFreed else {
 return print("Range not full! Prefetcher return.")
 }
 return executePrefetchValue(for: for: elem)
 }
 return executePrefetchCarefully(for: elem, memory: memory, canBeFreed: canBeFreed)
 }
 
 
 /* MAYBE NICER TO BREAK?
 switch cacher.limit {
 case .none:
 // ✅ GO AHEAD AND PREFETCH
 break
 case let .count(max):
 if (cacher.cachedResults.count < max || canBeFreed) {
 // ✅ GO AHEAD AND PREFETCH
 break
 }
 return print("Count full and cache can't be freed! Prefetcher return.")
 case let .size(sizing):
 if let size = sizing.approximateSize(of: elem), cacher.usedMemory + size < sizing.max {
 if cacher.usedMemory + size < sizing.max || canBeFreed {
 // ✅ GO AHEAD AND PREFETCH
 break
 }
 else {
 return print("Memory full and cache can't be freed! Prefetcher return.")
 }
 }
 return executePrefetchCheckSizing(for: elem, sizing: sizing, canBeFreed: canBeFreed)
 }
 
 return executePrefetchValue(for: for: elem)*/
 
 
 /* OLD WAYS:
 // If using averageSize, don't measure anything. Get size from average!
 if precacher.options.approximateSizeByAverage {
 size = cacher.averageResultSize
 }
 // If not average, try to measure byElement
 else if let approximatedSize = cacher.approximateSize(of: elem) {
 size = approximatedSize
 }
 
 
 // If size is known by now, see if it's too big already
 if let size = size, !cacher.couldFit(size: size) && !rangeIsFullyCached {
 print("Range not full! Prefetcher return.")
 return
 }
 
 // Size could still be nil, fetch the item and calculate the size:
 isPrefetching = true
 return executeFetchValue(for: elem) { value in
 self.isPrefetching = false
 guard let value = value else { return }
 // If size is nil, calculate by analizing the result:
 if size == nil {
 size = cacher.approximateSize(of: value, for: elem)
 }
 guard let size = size, cacher.couldFit(size: size) || rangeIsFullyCached else {
 print("Range not full or size may still be unkown! Prefetcher return.")
 return
 }
 cacher.cache(value,removingAllowed: true, for: elem)
 }*/
 }
 
 */

/*
 // LIMIT LIMIT LIMIT
 func executePrefetchCarefully(for key: Key, memory: Cacher.Limit.Memory, canBeFreed: Bool) {
 isPrefetching = true
 guard let cacher = cacher else { return }
 return executeFetchValue(for: elem) { value in
 self.isPrefetching = false
 guard let value = value else { return }
 // If size is nil, calculate by analizing the result:
 let size = memory.approximateSize(of: value, for: elem)
 let usedMemory = cacher.usedMemory(memoryLimit: memory)
 guard (usedMemory + size < memory.max) || canBeFreed else {
 print("Range not full or size may still be unkown! Prefetcher return.")
 return
 }
 self.cacher!.cache(value,removingAllowed: true, for: elem)
 }
 } */
