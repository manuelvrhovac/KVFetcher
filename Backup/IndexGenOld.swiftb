//
//  IndexGenOld.swift
//  Wideshow4
//
//  Created by Manuel Vrhovac on 29/03/2019.
//  Copyright Â© 2019 Manuel Vrhovac. All rights reserved.
//

import Foundation

/*
 enum IndexGeneratorDirection: Equatable {
 /// Indexes after current are near indexes. Example: 1, 2, 3, 4...
 case upcoming
 // Indexes before current. Example: -1, -2, -3
 case past
 /// Both indexes above and under current are near indexes. Example(rarity:3): 0, 1, 2, -1, 3, 4, 5, -2...
 case mixed(rarity: Int)
 case custom(offsets: [Int])
 }
 
 protocol IndexGeneratorDataSource {
 func currentIndex(for generator: IndexGenerator?) -> Int
 func count(for generator: IndexGenerator?) -> Int
 }*/

/*
 extension IndexGeneratorDataSource {
 func count(for generator: IndexGenerator?) -> Int {
 return 0
 }
 }*/

/*
 class IndexGeneratorOld {
 
 typealias Block = () -> Int
 
 enum Source {
 case blocks(currentIndex: Block, count: Block)
 case dataSource(IndexGeneratorDataSource)
 }
 
 /// This is where the generator gets the currentIndex and count from.
 var source: Source
 
 /// How many indexes against keysToSkip before returning nil
 var range: Int
 
 /// Next index includes current
 var includesCurrent: Bool = true
 
 /// Where to go from currentIndex
 var direction: IndexGeneratorDirection
 
 /// Take from behind when index is negative, and take from beginning when > count. Default: true
 var overflowAllowed: Bool = true
 
 init(range: Int,
 direction: IndexGeneratorDirection,
 currentIndex: @escaping Block,
 count: @escaping Block,
 includesCurrent: Bool = true,
 overflowAllowed: Bool = true) {
 self.range = range
 self.direction = direction
 self.source = .blocks(currentIndex: currentIndex, count: count)
 self.includesCurrent = includesCurrent
 self.overflowAllowed = overflowAllowed
 }
 
 init(range: Int,
 direction: IndexGeneratorDirection,
 dataSource: IndexGeneratorDataSource,
 includesCurrent: Bool = true,
 overflowAllowed: Bool = true) {
 self.range = range
 self.direction = direction
 self.source = .dataSource(dataSource)
 self.includesCurrent = includesCurrent
 self.overflowAllowed = overflowAllowed
 }
 
 init(customOffsets: [Int], source: Source) {
 self.range = customOffsets.count
 self.direction = .custom(offsets: customOffsets)
 self.source = source
 }
 
 var count: Int? {
 switch source {
 case .blocks(_, let count):
 return count()
 case .dataSource(let dataSource):
 return dataSource.count(for: self)
 }
 }
 
 var currentIndex: Int? {
 switch source {
 case .blocks(let currentIndex, _):
 return currentIndex()
 case .dataSource(let dataSource):
 return dataSource.count(for: self)
 }
 }
 
 var nextIndex: Int? {
 return nextIndex(after: currentIndex)
 }
 
 /*/// Creates nextIndex after specific index
 func nextIndex(after index: Int?) -> Int? {
 guard let count = count else { return nil }
 guard let index = index?.limitedBy(count: count) else { return nil }
 var range = self.range
 if range < 1 { range = 1 }
 else if range > count { range = count }
 
 }*/
 
 /// Creates nextIndex after specific index
 func nextIndex(after index: Int?) -> Int? {
 guard let index = index else { return nil }
 return nextIndexes(after: index).first
 }
 
 
 
 var nextIndexes: [Int] {
 return nextIndexes(after: currentIndex)
 }
 
 /// Create X indexes after specific index (X = range)
 func nextIndexes(after index: Int?) -> [Int] {
 guard let count = count else { return [] }
 guard let index = index?.limitedBy(count: count) else { return [] }
 var range = self.range
 if range < 1 { range = 1 }
 else if range > count { range = count }
 
 let increments = createIncrements()
 
 // offset increments with currentIndex
 var nextIndexes = increments.map { index + $0 }
 
 // if overflow allowed, turn negative indexes into positive counting back
 //(ex. current 2, 3, 1, 4, 5, 0, 6, 7, 99, 8, 9, 98, 10...
 if overflowAllowed {
 nextIndexes = nextIndexes.map { ($0+count)%count }
 }
 
 // drop indexes outside of range
 nextIndexes = nextIndexes.filter { 0..<count ~= $0}
 
 return nextIndexes
 }
 
 
 /// Create X increments (X = count)
 private func createIncrements() -> [Int] {
 let start = includesCurrent ? 0 : 1
 switch self.direction {
 case .upcoming:
 // start 3, count 10
 // 3, 4, 5, 6, 7, 8, 9, 10, 11, 12
 return Array(start...(range+start))
 case .past:
 // start 3, count 10
 // 3, 2, 1, 0, -1, -2, -3, -4, -5, -6
 return Array((start-range+1)...start).reversed()
 
 case .custom(let customOffsets):
 return customOffsets
 
 case .mixed(var rarity):
 // start 3, count 10, rarity 2
 // 3, 4, 2, 5, 6, 1, 7, 8, 0, 9
 var increments = Array(start...(range+start))
 rarity = rarity < 1 ? 1 : rarity
 for index in 1..<range {
 let insertionIndex = index*(rarity+1) - 1
 if insertionIndex >= increments.count { break }
 increments.insert(-index, at: insertionIndex)
 }
 return Array(increments[0..<range])
 }
 }
 
 
 }
 */
