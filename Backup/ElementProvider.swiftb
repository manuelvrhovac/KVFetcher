//
//  NearAssetDataSource.swift
//  Wideshow4
//
//  Created by Manuel Vrhovac on 20/08/2018.
//  Copyright Â© 2018 Manuel Vrhovac. All rights reserved.
//

import Foundation
import Photos

/*
protocol ElementProviderDataSource {
    func keys<Element: Hashable>(for precacher: ElementProvider<Element>?) -> [Element]
    func keysToSkip<Element: Hashable>(for precacher: ElementProvider<Element>?) -> [Element]
    func currentIndex<Element: Hashable>(for precacher: ElementProvider<Element>?) -> Int
}

// Used instead of dataSource (delegate) pattern - using closures is sometimes easier.
struct ElementSourceDataprecacherClosures<Element>: ElementProviderDataSource {
    let keys: () -> [Element]
    let keysToSkip: () -> [Element]
    let currentIndex: () -> Int
    
    func keys<Element>(for precacher: ElementProvider<Element>?) -> [Element] where Element : Hashable {
        return keys() as! [Element]
    }
    
    func keysToSkip<Element>(for precacher: ElementProvider<Element>?) -> [Element] where Element : Hashable {
        return keysToSkip() as! [Element]
    }
    
    func currentIndex<Element>(for precacher: ElementProvider<Element>?) -> Int where Element : Hashable {
        return currentIndex()
    }
}*/

/**
 ElementSource returns objects when needed and when there's a chance they will be needed soon.
 
 For example, if user has an album of 100 photos and is currently looking at photo 40, ElementSource is used to fetch and cache the next 10 photos. To be able to do that, it needs to know what photos to cache ('keys') have already been cached ('keysToSkip') from the 'source' property (closures or delegate). The range and direction are defined in the 'indexGenerator' property. IndexGenerator needs to know what index is user currently on and how many

*/

extension ElementProviderOld.Options {
    init(range: Int, offset: Int, direction: Direction) {
        self.init(range: range, offset: offset, direction: direction, includesCurrent: true, overflowAllowed: true)
    }
}

class ElementProviderOld<Element: Hashable>: NSObject {
    
    struct Closures {
        var keys: () -> [Element]
        var keysToSkip: () -> [Element]
        var currentIndex: () -> Int
        
        static var empty: Closures {
            return Closures(keys: { return [] }, keysToSkip: { return [] }, currentIndex: { return 0 })
        }
    }
    
    
    struct Options {
        enum Direction {
            case upcoming
            case past
            case mixed
        }
        let range: Int
        let offset: Int
        let direction: Direction
        let includesCurrent: Bool
        let overflowAllowed: Bool
    }
    
    // MARK: - Properties
    
    var precacherClosures: Closures!
    var options: Options
    
    // MARK: - Init
    
    
    init(options: Options, precacherClosures: Closures) {
        self.options = options
        self.precacherClosures = precacherClosures
    }
    
    var next: Element? {
        let currentIndex = precacherClosures.currentIndex()
        let keys = precacherClosures.keys()
        let keysToSkip = precacherClosures.keysToSkip()
        let offset = options.offset
        let ico = options.includesCurrent ? 0 : 1
        let count = keys.count
        for timesChecked in ico ... options.range {
            var dir: Int { //
                switch options.direction {
                case .upcoming: // 0, 1, 2, 3, 4, 5
                    return +1
                case .past: // ex. for count=30: 0, 29, 1, 28, 2, 27, 3
                    return -1
                case .mixed: // ex. for count=30: 0, 1, 29, 2, 28, 3, 27, 4...
                    return (timesChecked%2 != ico ? 1 : -1)*((timesChecked+ico+1)/2)
                }
            }
            var nowIndex = currentIndex + offset + timesChecked*dir + ico
            if nowIndex.isOverflown(count: count) && !options.overflowAllowed {
                return nil
            }
            nowIndex = nowIndex.fixOverflow(count: count)
            let foundElement = keys[nowIndex]
            if !keysToSkip.contains(foundElement) {
                if let asset = foundElement as? PHAsset {
                    print("Found new key to fetch \(asset.localIdentifier)")
                }
                return foundElement
            }
        }
        return nil
    }
    
}
