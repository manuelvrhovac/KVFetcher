//
//  CacherProtocol.swift
//  Wideshow4
//
//  Created by Manuel Vrhovac on 08/10/2018.
//  Copyright Â© 2018 Manuel Vrhovac. All rights reserved.
//

import Foundation

// MARK: -

/*

class ElementCacher<Delegate: ElementCacherDelegate> {
    
    
    typealias Element = Delegate.Element
    typealias Result = Delegate.Result
    typealias Completion = (Result, Quality) -> Void
    typealias TheDelegate = Delegate
    
    var keyProvider: ElementSource<Element>!
    var indexGenerator: IndexGenerator!
    var delegate: Delegate!
    
    fileprivate var isLoading: Bool!
    fileprivate var checkNextElementTimer: Timer!
    
    fileprivate var priorityElement: Element!
    fileprivate var priorityBlock: ((Result, TransformType) -> Void)!
    
    fileprivate(set) var values: [Delegate.Element : Delegate.Result] = [:]
    fileprivate(set) var quickResults: [Delegate.Element : Delegate.Result] = [:]
    
    
    // MARK:  Methods
    
    
    init(/*delegate: Delegate!, */keyProvider: ElementSource<Element>! = nil, indexGenerator: IndexGenerator! = nil) {
        //self.delegate = delegate
        self.keyProvider = keyProvider
        self.indexGenerator = indexGenerator
        startCaching()
    }
    
    private init() {
        startCaching()
    }
    
    public func transform(_ key: Keylement, method: Method, completion: Completion?) {
        if let existing = values[key] {
            completion?(existing, .full)
            return
        }
        switch method {
        case .quickNow: fetchQuickNow(key, completion: completion)
        case .now: fetchFullNow(key, completion: completion)
        case .asap: fetchFullAsap(key, completion: completion)
        }
    }
    
    
    fileprivate func approximateSizeCalculator(of key: Keylement) -> Double {
        return delegate.approximateSizeCalculator(of: key, for: self)
    }
    
    fileprivate func maxSizeOfTransformBlock() -> Double {
        return delegate.maxSizeOfTransformBlock(for: self)
    }
    
    fileprivate func maxSizeOfQuickTransformBlock() -> Double {
        return delegate.maxSizeOfQuickTransformBlock(for: self)
    }
    
    fileprivate func quickTransform(for key: Keylement, completion: @escaping Completion) {
        delegate.quickTransform(key, for: self) { (value,type) in
            completion(value,type)
        }
    }
    
    fileprivate func transform(for key: Keylement, completion: @escaping Completion) {
        delegate.quickTransform(key, for: self) { (value,type) in
            completion(value,type)
        }
    }
    
    
    /// Stop background caching
    fileprivate func stopCaching() {
        checkNextElementTimer?.invalidate()
    }
    
    /// Start caching added assets in the background
    fileprivate func startCaching() {
        checkNextElementTimer?.invalidate()
        checkNextElementTimer = Timer.scheduledTimer(withTimeInterval: 0.01, repeats: true) { _ in
            self.checkNextElement()
        }
    }
    
    
    fileprivate func checkNextElement() {
        if isLoading == nil { isLoading = false }
        guard !isLoading else { return }
        if let priorityElement = priorityElement, let priorityBlock = priorityBlock {
            self.priorityElement = nil
            self.priorityBlock = nil
            return fetchFullNow(priorityElement) { value, quality in
                priorityBlock(value,quality)
            }
        }
        if let nextElement = keyProvider?.next {
            // if maxSize is reached, then don't continue fetching more photos automatically
            //let allResults = Array(values.values)
            let approximateSize = approximateSizeCalculator(of: nextElement/*,/*for: sss*/*/)
            guard approximateSize <= maxSizeOfTransformBlock(/*for: sss*/) else {
                checkNextElementTimer.invalidate()
                return
            }
            
            fetchFullNow(nextElement, completion: nil)
        }
    }
    
    //private var sss: ElementCacher<Self> { return self as! ElementCacher<Self> }
    
    fileprivate func fetchFullNow(_ key: Keylement, completion: Completion?) {
        //print("Checking existing from: \(self.values)")
        if let existing = values[key] {
            completion?(existing, .full)
            return
        }
        isLoading = true
        transform(for: key/*, for: sss*/) { value,_  in
            self.isLoading = false
            self.values[key] = value
            //print("Results now: \(self.values)")
            completion?(value,.full)
        }
    }
    
    fileprivate func fetchQuickNow(_ key: Keylement, completion: Completion?) {
        if let existing = quickResults[key] {
            completion?(existing, .quick)
            return
        }
        quickTransform(for: key/*, for: sss*/) { value, _ in
            self.quickResults[key] = value
            completion?(value,.quick)
        }
    }
    
    fileprivate func fetchFullAsap(_ key: Keylement, completion: Completion?) {
        if let existing = values[key] {
            completion?(existing, .full)
            return
        }
        self.priorityElement = key
        self.priorityBlock = completion
    }
    
    
}

extension ElementCacherDelegate {
    
    public func transform(_ key: Keylement, method: Method, completion: Completion?) {
        if let existing = cacher.values[key] {
            completion?(existing, .full)
            return
        }
        switch method {
        case .quickNow: cacher.fetchQuickNow(key, completion: completion)
        case .now: cacher.fetchFullNow(key, completion: completion)
        case .asap: cacher.fetchFullAsap(key, completion: completion)
        }
    }
}
*/

