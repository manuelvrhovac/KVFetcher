
import Foundation

// MARK: -
/*

fileprivate protocol CacherProtocol: class {
    
    // MARK: This protocol defines a normal cacher protocol
    associatedtype Element: Hashable
    associatedtype Result
    
    typealias Completion = (Result, Quality) -> Void
    
    
    func approximateSizeCalculator(of key: Keylement/*, /*for cacher: ElementCacher<Self>*/*/) -> Double
    func maxSizeOfTransformBlock(/*for cacher: ElementCacher<Self>*/) -> Double
    func maxSizeOfQuickTransformBlock(/*for cacher: ElementCacher<Self>*/) -> Double
    
    func transform(for key: Keylement/*, /*for cacher: ElementCacher<Self>*/*/, completion: @escaping Completion)
    func quickTransform(for key: Keylement/*, /*for cacher: ElementCacher<Self>*/*/, completion: @escaping Completion)
    
    var values: [Element: Result] { get set }
    var quickResults: [Element: Result] { get set }
    
    // MARK: User defined properties:
    
    var keyProvider: ElementSource<Element>! { get set }
    var indexGenerator: IndexGenerator! { get set }
    
    // MARK: Private properties:
    
    // Already transformed(cached) keys into values
    
    var isLoading: Bool!  { get set }
    var checkNextElementTimer: Timer! { get set }
    
    var priorityElement: Element! { get set }
    var priorityBlock: Completion! { get set }
    
    
}

extension CacherProtocol {
    
    
    /// Stop background caching
    func stopCaching() {
        checkNextElementTimer?.invalidate()
    }
    
    /// Start caching added assets in the background
    func startCaching() {
        checkNextElementTimer?.invalidate()
        checkNextElementTimer = Timer.scheduledTimer(withTimeInterval: 0.01, repeats: true) { _ in
            self.checkNextElement()
        }
    }
    
    
    func checkNextElement() {
        if isLoading == nil { isLoading = false }
        guard !isLoading else { return }
        if let priorityElement = priorityElement, let priorityBlock = priorityBlock {
            self.priorityElement = nil
            self.priorityBlock = nil
            return fetchFullNow(priorityElement) { value, quality in
                priorityBlock(value,quality)
            }
        }
        if let nextElement = keyProvider?.next {
            // if maxSize is reached, then don't continue fetching more photos automatically
            //let allResults = Array(values.values)
            let approximateSize = approximateSizeCalculator(of: nextElement/*,/*for: sss*/*/)
            guard approximateSize <= maxSizeOfTransformBlock(/*for: sss*/) else {
                checkNextElementTimer.invalidate()
                return
            }
            
            fetchFullNow(nextElement, completion: nil)
        }
    }
    
    //private var sss: ElementCacher<Self> { return self as! ElementCacher<Self> }
    
    func fetchFullNow(_ key: Keylement, completion: Completion?) {
        //print("Checking existing from: \(self.values)")
        if let existing = values[key] {
            completion?(existing, .normal)
            return
        }
        isLoading = true
        transform(for: key/*, for: sss*/) { value,_  in
            self.isLoading = false
            self.values[key] = value
            //print("Results now: \(self.values)")
            completion?(value,.normal)
        }
    }
    
    func fetchQuickNow(_ key: Keylement, completion: Completion?) {
        if let existing = quickResults[key] {
            completion?(existing, .quick)
            return
        }
        quickTransform(for: key/*, for: sss*/) { value, _ in
            self.quickResults[key] = value
            completion?(value,.quick)
        }
    }
    
    func fetchFullAsap(_ key: Keylement, completion: Completion?) {
        if let existing = values[key] {
            completion?(existing, .normal)
            return
        }
        self.priorityElement = key
        self.priorityBlock = completion
    }
    
}
*/

